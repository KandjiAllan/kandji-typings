/* eslint-disable */
/**
 * This file was automatically generated by mdm-docs-parser.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run mdm-docs-parser:generate to regenerate this file.
 */

/**
 * Use this section to define settings for VPN access.
 */
export interface ComAppleVpnManaged {
  /**
   * The type of the VPN, which defines which settings are appropriate for this VPN payload.
   * If the type is 'VPN' or 'TransparentProxy', then the system requires a value for 'VPNSubType'.
   * 'TransparentProxy' is only available in macOS. 'L2TP' and 'IPSec' aren't available in tvOS. 'AlwaysOn' is only available on iOS and Apple Watch pairing isn't supported with 'AlwaysOn'. For a previously paired Apple Watch, all phone-watch communications cease when 'AlwaysOn' is enabled. Not available in watchOS.
   */
  VPNType: "VPN" | "L2TP" | "IPSec" | "IKEv2" | "AlwaysOn" | "TransparentProxy";
  /**
   * An identifier for a vendor-specified configuration dictionary when the value for 'VPNType' is 'VPN'.
   * If 'VPNType' is 'VPN', the system requires this field. If the configuration targets a VPN solution that uses a network extension provider, then this field contains the bundle identifier of the app that contains the provider. Contact the VPN solution vendor for the value of the identifier.
   * If 'VPNType' is 'IKEv2', then the 'VPNSubType' field is optional and reserved for future use. If it's specified, it needs to contain an empty string.
   * Not available in watchOS.
   */
  VPNSubType?: string;
  /**
   * The description of the VPN connection that the system displays on the device. Not available in watchOS.
   */
  UserDefinedName: string;
  /**
   * The vendor-specific configuration dictionary, which the system reads only when 'VPNSubType' has a value. Not available in watchOS.
   */
  VendorConfig?: {
    /**
     * The Kerberos realm name. This value needs to be properly capitalized. Not available in watchOS.
     */
    Realm?: string;
    /**
     * The role to select when connecting to the server. This key is valid only for Juniper SSL. Not available in watchOS.
     */
    Role?: string;
    /**
     * The group to connect to on the head end. This key is only valid for Cisco AnyConnect. Not available in watchOS.
     */
    Group?: string;
    /**
     * The login group or domain. Not available in watchOS.
     */
    LoginGroupOrDomain?: string;
  };
  /**
   * The dictionary to use to specify a VPN when 'VPNType' is 'VPN', 'IPSec', or 'IKEv2'.
   */
  VPN?: {
    /**
     * The authentication method to use.
     */
    AuthenticationMethod?: "Password" | "Certificate" | "Password+Certificate";
    /**
     * The UUID of the certificate payload within the same profile to use for account credentials.
     */
    PayloadCertificateUUID?: string;
    /**
     * The VPN user password.
     */
    Password?: string;
    /**
     * The bundle identifier for the VPN provider. Not available in watchOS.
     */
    ProviderBundleIdentifier?: string;
    /**
     * If the VPN provider is implemented as a system extension, this field is required. Not available in watchOS.
     */
    ProviderDesignatedRequirement?: string;
    /**
     * If '1', disconnects after an on-demand connection idles.
     */
    DisconnectOnIdle?: 0 | 1;
    /**
     * The length of time to wait, in seconds, before disconnecting an on-demand connection. In watchOS, the maximum allowed value is '15'.
     */
    DisconnectOnIdleTimer?: number;
    /**
     * The type of VPN service. If the value is 'app-proxy', the service tunnels traffic at the app level. If the value is 'packet-tunnel', the service tunnels traffic at the IP layer. Not available in watchOS.
     */
    ProviderType?: "packet-tunnel" | "app-proxy";
    /**
     * If '1', routes all traffic through the VPN, with some exclusions. Several of the exclusions can be controlled with the ExcludeLocalNetworks, ExcludeCellularServices, and ExcludeAPNs properties. See the documentation for those properties.  The following traffic is always excluded from the tunnel. Not available in watchOS.
     *
     * * Traffic necessary for connecting and maintaining the device's network connection, such as DHCP.
     * * Traffic necessary for connecting to captive networks.
     * * Certain cellular services traffic that is not routable over the internet and is instead directly routed to the cellular network. See the ExcludeCellularServices property for more details.
     * * Network communication with a companion device such as a watchOS device.
     */
    IncludeAllNetworks?: 0 | 1;
    /**
     * If '1', all the VPN's non-default routes take precedence over any locally defined routes.
     * If 'IncludeAllNetworks' is '1', the system ignores the value of 'EnforceRoutes'.
     * Available in iOS 14.2 and later, and macOS 11 and later. Not available in watchOS.
     */
    EnforceRoutes?: 0 | 1;
    /**
     * If '1' and 'IncludeAllNetworks' is '1', routes all local network traffic outside the VPN. Not available in watchOS.
     */
    ExcludeLocalNetworks?: 0 | 1;
    /**
     * If '1' and 'IncludeAllNetworks' is '1', then the system excludes internet-routable network traffic for cellular services (VoLTE, Wi-Fi Calling, IMS, MMS, Visual Voicemail, etc.) from the tunnel. Note that some cellular carriers route cellular services traffic directly to the carrier network, bypassing the internet. Such cellular services traffic is always excluded from the tunnel. Not available in watchOS.
     */
    ExcludeCellularServices?: 0 | 1;
    /**
     * If '1' and 'IncludeAllNetworks' is '1', then the system excludes the network traffic for the Apple Push Notification service (APNs) from the tunnel. Not available in watchOS.
     */
    ExcludeAPNs?: 0 | 1;
    /**
     * If '1', enables VPN On Demand.
     */
    OnDemandEnabled?: 0 | 1;
    /**
     * If '1', the Connect On Demand toggle in Settings is disabled for this configuration. Available in iOS 14 and later. Not available in watchOS.
     */
    OnDemandUserOverrideDisabled?: 0 | 1;
    /**
     * A list of domain names. The system treats associated domain names as though they're associated with the 'OnDemandMatchDomainsOnRetry' key. This behavior can be overridden by 'OnDemandRules'. Not available in watchOS.
     */
    OnDemandMatchDomainsAlways?: string[];
    /**
     * A list of domain names. If the host name ends with one of these domain names, the system doesn't start the VPN automatically. The system uses this value to exclude a subdomain within an included domain.
     * In iOS 7 and later, this key is deprecated (but still supported) in favor of 'EvaluateConnection' actions in the 'OnDemandRules' dictionaries.
     * Not available in watchOS.
     */
    OnDemandMatchDomainsNever?: string[];
    /**
     * A list of domain names. If the host name ends with one of these domain names and a DNS query for that domain name fails, the system starts the VPN automatically.
     * In iOS 7 and later, this key is deprecated (but still supported) in favor of 'EvaluateConnection' actions in the 'OnDemandRules' dictionaries.
     * Not available in watchOS.
     */
    OnDemandMatchDomainsOnRetry?: string[];
    /**
     * An array of dictionaries defining On Demand Rules.
     */
    OnDemandRules?: {
      /**
       * The action to take if this dictionary matches the current network. Possible values are:
       * * 'Allow': Deprecated. Allow VPN On Demand to connect if triggered.
       * * 'Connect': Unconditionally initiate a VPN connection on the next network attempt.
       * * 'Disconnect': Tear down the VPN connection and don't reconnect on demand as long as this dictionary matches.
       * * 'EvaluateConnection': Evaluate the ActionParameters array for each connection attempt.
       * * 'Ignore:' Leave any existing VPN connection up, but don't reconnect on demand as long as this dictionary matches.
       * Only the 'Disconnect' action is available on watchOS 10 and later.
       */
      Action: "Allow" | "Connect" | "Disconnect" | "EvaluateConnection" | "Ignore";
      /**
       * A dictionary that provides rules similar to the 'OnDemandRules' dictionary, but evaluated on each connection instead of when the network changes. This value is only for use with dictionaries in which the 'Action' value is 'EvaluateConnection'. The system evaluates these dictionaries in order and the first dictionary that matches determines the behavior. Not available in watchOS.
       */
      ActionParameters?: {
        /**
         * The domains to apply this evaluation.
         */
        Domains: string[];
        /**
         * Defines the VPN behavior for the specified domains. Allowed values are:
         * * 'ConnectIfNeeded': The specified domains should trigger a VPN connection attempt if domain name resolution fails, such as when the DNS server indicates that it can't resolve the domain, responds with a redirection to a different server, or fails to respond (timeout).
         * * 'NeverConnect': The specified domains should never trigger a VPN connection attempt.
         */
        DomainAction: "ConnectIfNeeded" | "NeverConnect";
        /**
         * An array of IP addresses of DNS servers to use for resolving the specified domains. These servers don't need to be part of the device's current network configuration. If these DNS servers aren't reachable, the system establishes a VPN connection. These DNS servers need to be either internal DNS servers or trusted external DNS servers.
         * This key is valid only if the value of 'DomainAction' is 'ConnectIfNeeded'.
         */
        RequiredDNSServers?: string[];
        /**
         * An HTTP or HTTPS (preferred) URL to probe, using a GET request. If the URL's hostname can't be resolved, if the server is unreachable, or if the server doesn't respond with a 200 HTTP status code, a VPN connection is established in response.
         * This key is valid only if the value of 'DomainAction' is 'ConnectIfNeeded'.
         */
        RequiredURLStringProbe?: string;
      };
      /**
       * An array of domain names. This rule matches if any of the domain names in the specified list matches any domain in the device's search domains list.
       * The system supports a wildcard ('*') prefix. For example, '*.example.com' matches against either 'mydomain.example.com' or 'yourdomain.example.com'.
       */
      DNSDomainMatch?: string[];
      /**
       * An array of IP addresses. This rule matches if any of the network's specified DNS servers match any entry in the array.
       * The system supports matching with a single wildcard. For example, '17.*' matches any DNS server in the '17.0.0.0/8' subnet.
       */
      DNSServerAddressMatch?: string[];
      /**
       * An interface type. If specified, this rule matches only if the primary network interface hardware matches the specified type.
       */
      InterfaceTypeMatch?: "Ethernet" | "WiFi" | "Cellular";
      /**
       * An array of SSIDs to match against the current network. If the network isn't a Wi-Fi network or if the SSID doesn't appear in this array, the match fails.
       * Omit this key and the corresponding array to match against any SSID.
       */
      SSIDMatch?: string[];
      /**
       * A URL to probe. This rule matches when this URL is successfully fetched (returns a '200' HTTP status code) without redirection. Not available in watchOS.
       */
      URLStringProbe?: string;
    }[];
  };
  /**
   * The dictionary that contains IPv4 settings. Not available in watchOS.
   */
  IPv4?: {
    /**
     * If '1', the system sends all network traffic over VPN.
     */
    OverridePrimary?: 0 | 1;
  };
  /**
   * The dictionary to use when 'VPNType' is 'L2TP' or 'PTPP'. Not available in watchOS.
   */
  PPP?: {
    /**
     * The VPN account user name. This key is for use with L2TP and PPTP networks.
     */
    AuthName?: string;
    /**
     * If 'TokenCard' is '1', use this password for authentication. This keyis for use with L2TP and PPTP networks.
     */
    AuthPassword?: string;
    /**
     * If '1', uses a token card such as an RSA SecurID card for connecting. This key is for use with L2TP networks.
     */
    TokenCard?: 0 | 1;
    /**
     * The IP address or host name of VPN server. This key is for use with L2TP and PPTP networks.
     */
    CommRemoteAddress?: string;
    /**
     * An array of authentication plugins. For use of RSA SecurID, this array should only have one value: 'EAP-RSA'. This key is for use with L2TP and PPTP networks.
     */
    AuthEAPPlugins?: ("EAP-RSA" | "EAP-TLS" | "EAP-KRB")[];
    /**
     * An array of authentication protocols. For use of RSA SecurID, this array should have one value, 'EAP'. This key is for use with L2TP and PPTP networks.
     */
    AuthProtocol?: "EAP"[];
    /**
     * If '1' and 'CCPEnabled' is also '1', enables CCPMPPE128 encryption.
     */
    CCPMPPE40Enabled?: 0 | 1;
    /**
     * If '1' and 'CCPEnabled' is also '1', enables CCPMPPE40 encryption.
     */
    CCPMPPE128Enabled?: 0 | 1;
    /**
     * If '1', enables encryption on the connection. This key is for use with PPTP networks.
     */
    CCPEnabled?: 0 | 1;
    /**
     * If '1', disconnects after an on demand connection idles.
     */
    DisconnectOnIdle?: 0 | 1;
    /**
     * The length of time to wait before disconnecting an on demand connection
     */
    DisconnectOnIdleTimer?: number;
  };
  /**
   * The dictionary that contains IPSec settings. Not available in watchOS.
   */
  IPSec?: {
    /**
     * The IP address or host name of the VPN server.
     */
    RemoteAddress?: string;
    /**
     * The authentication method for L2TP and Cisco IPSec.
     */
    AuthenticationMethod?: "SharedSecret" | "Certificate";
    /**
     * The user name for the VPN account for Cisco IPSec.
     */
    XAuthName?: string;
    /**
     * The VPN account password for Cisco IPSec.
     */
    XAuthPassword?: string;
    /**
     * If '1', enables Xauth for Cisco IPSec VPNs.
     */
    XAuthEnabled?: 0 | 1;
    /**
     * A string that either has the value “Prompt” or isn't present.
     */
    XAuthPasswordEncryption?: "Prompt";
    /**
     * The name of the group. For hybrid authentication, the string needs to end with 'hybrid'.
     * Present only for Cisco IPSec if 'AuthenticationMethod' is 'SharedSecret'.
     */
    LocalIdentifier?: string;
    /**
     * Present only if 'AuthenticationMethod' is 'SharedSecret'. The value is 'KeyID'. The system uses this value for L2TP and Cisco IPSec VPNs.
     */
    LocalIdentifierType?: "KeyID";
    /**
     * The shared secret for this VPN account.
     * Only use this with L2TP and Cisco IPSec VPNs and if the 'AuthenticationMethod' key is to 'SharedSecret'.
     */
    SharedSecret?: string;
    /**
     * The UUID of the certificate payload within the same profile to use for the account credentials.
     * Only use this with Cisco IPSec VPNs and if the 'AuthenticationMethod' key is to 'Certificate'.
     */
    PayloadCertificateUUID?: string;
    /**
     * If 'true', prompts for a PIN when connecting to Cisco IPSec VPNs.
     */
    PromptForVPNPIN?: boolean;
    /**
     * If '1', disconnect after an on-demand connection idles.
     */
    DisconnectOnIdle?: 0 | 1;
    /**
     * The length of time to wait before disconnecting an on-demand connection.
     */
    DisconnectOnIdleTimer?: number;
    /**
     * If '1', enables bringing the VPN connection up on demand.
     */
    OnDemandEnabled?: 0 | 1;
    /**
     * Deprecated. A list of domain names. In iOS 7 and later, if this key is present, the system treats associated domain names as though they're associated with the 'OnDemandMatchDomainsOnRetry' key. This behavior can be overridden by 'OnDemandRules'.
     */
    OnDemandMatchDomainsAlways?: string[];
    /**
     * Deprecated. A list of domain names. In iOS 7 and later, this key is deprecated (but still supported) in favor of 'EvaluateConnection' actions in the 'OnDemandRules' dictionaries.
     */
    OnDemandMatchDomainsNever?: string[];
    /**
     * Deprecated. A list of domain names. In iOS 7 and later, this field is deprecated (but still supported) in favor of 'EvaluateConnection' actions in the 'OnDemandRules' dictionaries.
     */
    OnDemandMatchDomainsOnRetry?: string[];
    /**
     * The on-demand rules dictionary.
     */
    OnDemandRules?: {
      /**
       * The action to take if this dictionary matches the current network. Possible values are:
       * * 'Allow': Deprecated. Allow VPN On Demand to connect if triggered.
       * * 'Connect': Unconditionally initiate a VPN connection on the next network attempt.
       * * 'Disconnect': Tear down the VPN connection and don't reconnect on demand as long as this dictionary matches.
       * * 'EvaluateConnection': Evaluate the ActionParameters array for each connection attempt.
       * * 'Ignore:' Leave any existing VPN connection up, but don't reconnect on demand as long as this dictionary matches.
       * Only the 'Disconnect' action is available on watchOS 10 and later.
       */
      Action: "Allow" | "Connect" | "Disconnect" | "EvaluateConnection" | "Ignore";
      /**
       * A dictionary that provides rules similar to the 'OnDemandRules' dictionary, but evaluated on each connection instead of when the network changes. This value is only for use with dictionaries in which the 'Action' value is 'EvaluateConnection'. The system evaluates these dictionaries in order and the first dictionary that matches determines the behavior. Not available in watchOS.
       */
      ActionParameters?: {
        /**
         * The domains to apply this evaluation.
         */
        Domains: string[];
        /**
         * Defines the VPN behavior for the specified domains. Allowed values are:
         * * 'ConnectIfNeeded': The specified domains should trigger a VPN connection attempt if domain name resolution fails, such as when the DNS server indicates that it can't resolve the domain, responds with a redirection to a different server, or fails to respond (timeout).
         * * 'NeverConnect': The specified domains should never trigger a VPN connection attempt.
         */
        DomainAction: "ConnectIfNeeded" | "NeverConnect";
        /**
         * An array of IP addresses of DNS servers to use for resolving the specified domains. These servers don't need to be part of the device's current network configuration. If these DNS servers aren't reachable, the system establishes a VPN connection. These DNS servers need to be either internal DNS servers or trusted external DNS servers.
         * This key is valid only if the value of 'DomainAction' is 'ConnectIfNeeded'.
         */
        RequiredDNSServers?: string[];
        /**
         * An HTTP or HTTPS (preferred) URL to probe, using a GET request. If the URL's hostname can't be resolved, if the server is unreachable, or if the server doesn't respond with a 200 HTTP status code, a VPN connection is established in response.
         * This key is valid only if the value of 'DomainAction' is 'ConnectIfNeeded'.
         */
        RequiredURLStringProbe?: string;
      };
      /**
       * An array of domain names. This rule matches if any of the domain names in the specified list matches any domain in the device's search domains list.
       * The system supports a wildcard ('*') prefix. For example, '*.example.com' matches against either 'mydomain.example.com' or 'yourdomain.example.com'.
       */
      DNSDomainMatch?: string[];
      /**
       * An array of IP addresses. This rule matches if any of the network's specified DNS servers match any entry in the array.
       * The system supports matching with a single wildcard. For example, '17.*' matches any DNS server in the '17.0.0.0/8' subnet.
       */
      DNSServerAddressMatch?: string[];
      /**
       * An interface type. If specified, this rule matches only if the primary network interface hardware matches the specified type.
       */
      InterfaceTypeMatch?: "Ethernet" | "WiFi" | "Cellular";
      /**
       * An array of SSIDs to match against the current network. If the network isn't a Wi-Fi network or if the SSID doesn't appear in this array, the match fails.
       * Omit this key and the corresponding array to match against any SSID.
       */
      SSIDMatch?: string[];
      /**
       * A URL to probe. This rule matches when this URL is successfully fetched (returns a '200' HTTP status code) without redirection. Not available in watchOS.
       */
      URLStringProbe?: string;
    }[];
  };
  /**
   * The dictionary to use when 'VPNType' is 'IKEv2'.
   */
  IKEv2?: {
    /**
     * The IP address or host name of the VPN server.
     */
    RemoteAddress: string;
    /**
     * Identifier of the IKEv2 client.
     */
    LocalIdentifier: string;
    /**
     * The remote identifier.
     */
    RemoteIdentifier: string;
    /**
     * The type of authentication method for the VPN.
     * To enable EAP-only authentication, set this to 'None' and 'ExtendedAuthEnabled' to '1'. If this is 'None' and the 'ExtendedAuthEnabled' key isn't set, the authentication configuration defaults to 'SharedSecret'.
     */
    AuthenticationMethod: "None" | "SharedSecret" | "Certificate";
    /**
     * The type of 'PayloadCertificateUUID' to use for IKEv2 machine authentication. If this key is included, the system requires a value for 'ServerCertificateIssuerCommonName'.
     */
    CertificateType?: "RSA" | "ECDSA256" | "ECDSA384" | "ECDSA521" | "RSA-PSS";
    /**
     * The UUID of the certificate payload within the same profile to use as the account credential. If the value of 'AuthenticationMethod' is 'Certificate', the system sends this certificate out for IKEv2 machine authentication. If extended authentication (EAP) is used, the system sends this certificate out for EAP-TLS authentication.
     */
    PayloadCertificateUUID?: string;
    /**
     * If 'AuthenticationMethod' is 'SharedSecret', this value is used for IKE authentication.
     */
    SharedSecret?: string;
    /**
     * If '1', enables EAP-only authentication.
     */
    ExtendedAuthEnabled?: 0 | 1;
    /**
     * The user name to use for authentication.
     */
    AuthName?: string;
    /**
     * The password to use for authentication.
     */
    AuthPassword?: string;
    /**
     * If '1', enables VPN up on demand.
     */
    OnDemandEnabled?: 0 | 1;
    /**
     * If '1', the system disables the Connect On Demand toggle in Settings for this configuration.
     */
    OnDemandUserOverrideDisabled?: 0 | 1;
    /**
     * A list of rules that determine when and how to use an OnDemand VPN.
     */
    OnDemandRules?: {
      /**
       * The action to take if this dictionary matches the current network. Possible values are:
       * * 'Allow': Deprecated. Allow VPN On Demand to connect if triggered.
       * * 'Connect': Unconditionally initiate a VPN connection on the next network attempt.
       * * 'Disconnect': Tear down the VPN connection and don't reconnect on demand as long as this dictionary matches.
       * * 'EvaluateConnection': Evaluate the ActionParameters array for each connection attempt.
       * * 'Ignore:' Leave any existing VPN connection up, but don't reconnect on demand as long as this dictionary matches.
       * Only the 'Disconnect' action is available on watchOS 10 and later.
       */
      Action: "Allow" | "Connect" | "Disconnect" | "EvaluateConnection" | "Ignore";
      /**
       * A dictionary that provides rules similar to the 'OnDemandRules' dictionary, but evaluated on each connection instead of when the network changes. This value is only for use with dictionaries in which the 'Action' value is 'EvaluateConnection'. The system evaluates these dictionaries in order and the first dictionary that matches determines the behavior. Not available in watchOS.
       */
      ActionParameters?: {
        /**
         * The domains to apply this evaluation.
         */
        Domains: string[];
        /**
         * Defines the VPN behavior for the specified domains. Allowed values are:
         * * 'ConnectIfNeeded': The specified domains should trigger a VPN connection attempt if domain name resolution fails, such as when the DNS server indicates that it can't resolve the domain, responds with a redirection to a different server, or fails to respond (timeout).
         * * 'NeverConnect': The specified domains should never trigger a VPN connection attempt.
         */
        DomainAction: "ConnectIfNeeded" | "NeverConnect";
        /**
         * An array of IP addresses of DNS servers to use for resolving the specified domains. These servers don't need to be part of the device's current network configuration. If these DNS servers aren't reachable, the system establishes a VPN connection. These DNS servers need to be either internal DNS servers or trusted external DNS servers.
         * This key is valid only if the value of 'DomainAction' is 'ConnectIfNeeded'.
         */
        RequiredDNSServers?: string[];
        /**
         * An HTTP or HTTPS (preferred) URL to probe, using a GET request. If the URL's hostname can't be resolved, if the server is unreachable, or if the server doesn't respond with a 200 HTTP status code, a VPN connection is established in response.
         * This key is valid only if the value of 'DomainAction' is 'ConnectIfNeeded'.
         */
        RequiredURLStringProbe?: string;
      };
      /**
       * An array of domain names. This rule matches if any of the domain names in the specified list matches any domain in the device's search domains list.
       * The system supports a wildcard ('*') prefix. For example, '*.example.com' matches against either 'mydomain.example.com' or 'yourdomain.example.com'.
       */
      DNSDomainMatch?: string[];
      /**
       * An array of IP addresses. This rule matches if any of the network's specified DNS servers match any entry in the array.
       * The system supports matching with a single wildcard. For example, '17.*' matches any DNS server in the '17.0.0.0/8' subnet.
       */
      DNSServerAddressMatch?: string[];
      /**
       * An interface type. If specified, this rule matches only if the primary network interface hardware matches the specified type.
       */
      InterfaceTypeMatch?: "Ethernet" | "WiFi" | "Cellular";
      /**
       * An array of SSIDs to match against the current network. If the network isn't a Wi-Fi network or if the SSID doesn't appear in this array, the match fails.
       * Omit this key and the corresponding array to match against any SSID.
       */
      SSIDMatch?: string[];
      /**
       * A URL to probe. This rule matches when this URL is successfully fetched (returns a '200' HTTP status code) without redirection. Not available in watchOS.
       */
      URLStringProbe?: string;
    }[];
    /**
     * One of the following:
     * * 'None': No keepalive.
     * * 'Low': Send keepalive every 30 minutes.
     * * 'Medium': Send keepalive every 10 minutes.
     * * 'High': Send keepalive every 1 minute.
     * Not available in watchOS.
     */
    DeadPeerDetectionRate?: "None" | "Low" | "Medium" | "High";
    /**
     * Common Name of the server certificate issuer. If set, this field causes IKE to send a certificate request based on this certificate issuer to the server. This key is required if the 'CertificateType' key is included and the 'ExtendedAuthEnabled' key is '1'.
     */
    ServerCertificateIssuerCommonName?: string;
    /**
     * The common name of the server certificate. The system uses this name to validate the certificate sent by the IKE server. If not set, the system uses the remote identifier to validate the certificate.
     */
    ServerCertificateCommonName?: string;
    /**
     * The minimum TLS version to use with EAP-TLS authentication.
     */
    TLSMinimumVersion?: "1.0" | "1.1" | "1.2";
    /**
     * The maximum TLS version to use with EAP-TLS authentication.
     */
    TLSMaximumVersion?: "1.0" | "1.1" | "1.2";
    /**
     * If '1', negotiations should use IKEv2 Configuration Attribute 'INTERNAL_IP4_SUBNET' and 'INTERNAL_IP6_SUBNET'.
     */
    UseConfigurationAttributeInternalIPSubnet?: 0 | 1;
    /**
     * If '1', the system disables MOBIKE.
     */
    DisableMOBIKE?: 0 | 1;
    /**
     * If '1', the system disables IKEv2 redirect. If not set, the system redirects an IKEv2 connection when it receives a redirect request from the server.
     */
    DisableRedirect?: 0 | 1;
    /**
     * If '1', enables NAT keepalive offload for Always On VPN IKEv2 connections. The device sends keepalive packets to maintain NAT mappings for IKEv2 connections that have a NAT on the path. It sends keepalive packets at regular intervals when the device is awake. If 'NATKeepAliveOffloadEnable' is '1', the system offloads keepalive packets to hardware while the device is asleep.
     * NAT keepalive offload has an impact on the battery life due to the extra workload during sleep. The default interval for the keepalive offload packets is 20 seconds over WiFi and 110 seconds over Cellular interface. The default NAT keepalive works well on networks with small NAT mapping timeouts but imposes a potential battery impact. If a network has larger NAT mapping timeouts, larger keepalive intervals may be safely used to minimize battery impact. Modify the keepalive interval through the 'NATKeepAliveInterval' key.
     */
    NATKeepAliveOffloadEnable?: 0 | 1;
    /**
     * The NAT Keepalive interval for Always On VPN IKEv2 connections. This value controls the interval that the device sends keepalive offload packets. The minimum value is 20 seconds. If no key is specified, the default is 20 seconds over Wi-Fi and 110 seconds over a cellular interface.
     */
    NATKeepAliveInterval?: number;
    /**
     * If '1',  enables Perfect Forward Secrecy (PFS) for IKEv2 Connections.
     */
    EnablePFS?: 0 | 1;
    /**
     * If '1', the system performs a certificate revocation check for IKEv2 connections. This is a best-effort revocation check and server response timeouts won't cause it to fail.
     */
    EnableCertificateRevocationCheck?: 0 | 1;
    /**
     * If '1', the system enables a tunnel over cellular data to carry traffic that's eligible for WiFi Assist and also requires VPN.
     * Enabling fallback requires that the server support multiple tunnels for a single user.
     * This field is available in iOS 13 and later, and tvOS 17 and later. Not available in watchOS.
     */
    EnableFallback?: 0 | 1;
    /**
     * The Maximum Transmission Unit (MTU) specifies the maximum size in bytes of each packet that the system sends over the IKEv2 VPN interface. Available in iOS 14 and later, and macOS 11 and later.
     */
    MTU?: number;
    /**
     * If '1', then the system routes all network traffic through the VPN, with some controllable exclusions, such as 'ExcludeLocalNetworks', 'ExcludeCellularServices', and 'ExcludeAPNs' properties. The system always excludes the following traffic from the tunnel:
     * * Traffic necessary for connecting and maintaining the device's network connection, such as DHCP.
     * * Traffic necessary for connecting to captive networks.
     * * Certain cellular services traffic that's not routable over the internet and is instead directly routed to the cellular network. See the 'ExcludeCellularServices' field for more information.
     * * Network communication with a companion device such as a watchOS device.
     */
    IncludeAllNetworks?: 0 | 1;
    /**
     * If '1', all the VPN's non-default routes take precedence over any locally-defined routes. If 'IncludeAllNetworks' is '1', the system ignores 'EnforceRoutes'.
     */
    EnforceRoutes?: 0 | 1;
    /**
     * If '1' and either 'IncludeAllNetworks' or 'EnforceRoutes' are '1', then the system routes local network traffic outside of the VPN. The default for this value is '0' on macOS and '1' on iOS.
     */
    ExcludeLocalNetworks?: 0 | 1;
    /**
     * If '1' and 'IncludeAllNetworks' is '1', the system excludes internet-routable network traffic for cellular services (VoLTE, Wi-Fi Calling, IMS, MMS, Visual Voicemail, etc.) from the tunnel. Note that some cellular carriers route cellular services traffic directly to the carrier network, bypassing the internet. Such cellular services traffic is always excluded from the tunnel.
     */
    ExcludeCellularServices?: 0 | 1;
    /**
     * If '1' and 'IncludeAllNetworks' is '1', the system excludes network traffic for the Apple Push Notification service (APNs) from the tunnel.
     */
    ExcludeAPNs?: 0 | 1;
    /**
     * These parameters apply to Child Security Association unless 'ChildSecurityAssociationParameters' is specified.
     */
    IKESecurityAssociationParameters?: {
      /**
       * The encryption algorithm.
       */
      EncryptionAlgorithm?: "DES" | "3DES" | "AES-128" | "AES-256" | "AES-128-GCM" | "AES-256-GCM" | "ChaCha20Poly1305";
      /**
       * The integrity algorithm.
       */
      IntegrityAlgorithm?: "SHA1-96" | "SHA1-160" | "SHA2-256" | "SHA2-384" | "SHA2-512";
      /**
       * The Diffie-Hellman group. For AlwaysOn VPN, minimum allowed Diffie Hellman Group is '14' in iOS 14.2 and later.
       */
      DiffieHellmanGroup?: 1 | 2 | 5 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 31 | 32;
      /**
       * The SA lifetime (rekey interval) in minutes.
       */
      LifeTimeInMinutes?: number;
    };
    /**
     * The 'ChildSecurityAssociationParameters' dictionaries.
     */
    ChildSecurityAssociationParameters?: {
      /**
       * The encryption algorithm.
       */
      EncryptionAlgorithm?: "DES" | "3DES" | "AES-128" | "AES-256" | "AES-128-GCM" | "AES-256-GCM" | "ChaCha20Poly1305";
      /**
       * The integrity algorithm.
       */
      IntegrityAlgorithm?: "SHA1-96" | "SHA1-160" | "SHA2-256" | "SHA2-384" | "SHA2-512";
      /**
       * The Diffie-Hellman group. For AlwaysOn VPN, minimum allowed Diffie Hellman Group is '14' in iOS 14.2 and later.
       */
      DiffieHellmanGroup?: 1 | 2 | 5 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 31 | 32;
      /**
       * The SA lifetime (rekey interval) in minutes.
       */
      LifeTimeInMinutes?: number;
    };
  };
  /**
   * A dictionary to use for all VPN types.
   */
  DNS?: {
    /**
     * The transport protocol to communicate with the DNS server.
     */
    DNSProtocol: "Cleartext" | "HTTPS" | "TLS";
    /**
     * The URI template of a DNS-over-HTTPS server, as defined in RFC 8484, which needs to use the 'https://' scheme. The system uses the hostname or address in the URL to validate the server certificate. If 'ServerAddresses' isn't specified, the system uses the hostname or address in the URL to determine the server addresses. This key is required if the 'DNSProtocol' is 'HTTPS'.
     */
    ServerURL?: string;
    /**
     * The hostname of a DNS-over-TLS server to validate the server certificate, as defined in RFC 7858. If 'ServerAddresses' isn't specified, the system uses the hostname to determine the server addresses. This key is required if the 'DNSProtocol' is 'TLS'.
     */
    ServerName?: string;
    /**
     * The array of DNS server IP address strings. These IP addresses can be a mixture of IPv4 and IPv6 addresses.
     */
    ServerAddresses: string[];
    /**
     * The list of domain strings used to fully qualify single-label host names.
     */
    SearchDomains?: string[];
    /**
     * The primary domain of the tunnel.
     */
    DomainName?: string;
    /**
     * The list of domain strings used to determine which DNS queries use the DNS resolver settings in 'ServerAddresses'. The system uses this key to create a split DNS configuration where it resolves only hosts in certain domains using the tunnel's DNS resolver. The system uses the default resolver for hosts that aren't in one of the domains in this list.
     * If 'SupplementalMatchDomains' contains the empty string it becomes the default domain.
     * Split-tunnel configurations can direct all DNS queries to the VPN DNS servers before the primary DNS servers. If the VPN tunnel becomes the network's default route, the servers listed in 'ServerAddresses' become the default resolver and the system ignores the 'SupplementalMatchDomains' list.
     */
    SupplementalMatchDomains?: string[];
    /**
     * If '0', append the domains in the 'SupplementalMatchDomains' list to the resolver's list of search domains.
     */
    SupplementalMatchDomainsNoSearch?: 0 | 1;
    /**
     * That UUID that points to an identity certificate payload. The system uses this identity to authenticate the user to the DNS resolver.
     */
    PayloadCertificateUUID?: string;
  };
  /**
   * The dictionary to use to configure 'Proxies' for use with 'VPN'.
   */
  Proxies?: {
    /**
     * If 'true', enables automatic proxy configuration.
     */
    ProxyAutoConfigEnable?: 0 | 1;
    /**
     * If 'true', enables proxy auto discovery.
     */
    ProxyAutoDiscoveryEnable?: 0 | 1;
    /**
     * The URL to the location of the proxy auto-configuration file. Used only when 'ProxyAutoConfigEnable' is 'true'.
     */
    ProxyAutoConfigURLString?: string;
    /**
     * An array of domains that defines which hosts use proxy settings for hosts.
     */
    SupplementalMatchDomains?: string[];
    /**
     * If '1', enables proxy for HTTP traffic.
     */
    HTTPEnable?: 0 | 1;
    /**
     * The port number of the HTTP proxy. This field is required if 'HTTPProxy' is specified.
     */
    HTTPProxy?: string;
    /**
     * The host name of the HTTP proxy.
     */
    HTTPPort?: number;
    /**
     * The user name used for authentication.
     */
    HTTPProxyUsername?: string;
    /**
     * The password used for authentication.
     */
    HTTPProxyPassword?: string;
    /**
     * If 'true', enables proxy for HTTPS traffic.
     */
    HTTPSEnable?: 0 | 1;
    /**
     * The host name of the HTTPS proxy.
     */
    HTTPSProxy?: string;
    /**
     * The port number of the HTTPS proxy. This field is required if 'HTTPSProxy' is specified.
     */
    HTTPSPort?: number;
  };
  /**
   * The dictionary to use when 'VPNType' is 'AlwaysOn'. Not available in watchOS.
   */
  AlwaysOn?: {
    /**
     * If '1', allows the user to disable the VPN configuration.
     */
    UIToggleEnabled?: 0 | 1;
    /**
     * An array that contains an arbitrary number of tunnel configurations.
     */
    TunnelConfigurations: {
      /**
       * The type of connection, which needs to be 'IKEv2'.
       */
      ProtocolType: "IKEv2";
      /**
       * The interfaces to apply this configuration to.
       */
      Interfaces?: ("Cellular" | "WiFi")[];
    }[];
    /**
     * An array that contains an arbitrary number of service exceptions.
     */
    ServiceExceptions?: {
      /**
       * The name of a service that's exempt from Always On VPN. 'CellularServices' is available in iOS 11.3 and later; it exempts 'VoLTE', 'IMS' and 'MMS'. WiFiCalling is exempted in iOS 13.4 and later.
       */
      ServiceName: "VoiceMail" | "AirPrint" | "CellularServices";
      /**
       * The action to take with network connections from the named service.
       */
      Action: "Allow" | "Drop";
    }[];
    /**
     * An array that contains an arbitrary number of apps whose connections occur outside the VPN.
     */
    ApplicationExceptions?: {
      /**
       * The app's bundle identifier.
       */
      BundleIdentifier: string;
      /**
       * Limit the exception to only the specified list of protocols, with support for 'UDP' only.
       */
      LimitToProtocols?: "UDP"[];
    }[];
    /**
     * If '1', allows traffic from Captive Web Sheet outside the VPN tunnel.
     */
    AllowCaptiveWebSheet?: 0 | 1;
    /**
     * If '1', allows traffic from all captive networking apps outside the VPN tunnel to perform captive network handling.
     */
    AllowAllCaptiveNetworkPlugins?: 0 | 1;
    /**
     * The array of captive networking apps whose traffic is allowed outside the VPN tunnel, to perform captive network handling. Used only when 'AllowAllCaptiveNetworkPlugins 'is 'false'.
     */
    AllowedCaptiveNetworkPlugins?: {
      /**
       * The bundle identifier for the app that's allowed on the captive network.
       */
      BundleIdentifier: string;
    }[];
  };
  /**
   * The dictionary to use when 'VPNType' is 'TransparentProxy'. The keys in this dictionary are the same as the keys in the 'VPN' dictionary with the addition of the fields shown in the VPN.TransparentProxy dictionary. Not available in watchOS.
   */
  TransparentProxy?: {
    /**
     * A positive integer.
     */
    Order?: number;
  };
}
